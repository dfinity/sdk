use crate::value::{IDLField, IDLValue, IDLArgs};
use crate::types::{IDLType, PrimType, Label, TypeField, FuncType, FuncMode, Binding, Dec, IDLProg};
use crate::lexer::{Token, LexicalError, TmpIDLField};
use dfx_info::idl_hash;

grammar;

extern {
    type Location = usize;
    type Error = LexicalError;
    enum Token {
        "number" => Token::Number(<String>),
        "bool" => Token::Boolean(<bool>),
        "text" => Token::Text(<String>),
        "id" => Token::Id(<String>),
        "null" => Token::Null,
        "none" => Token::None,
        "opt" => Token::Opt,
        "vec" => Token::Vec,
        "record" => Token::Record,
        "variant" => Token::Variant,
        "func" => Token::Func,
        "service" => Token::Service,
        "oneway" => Token::Oneway,
        "query" => Token::Query,
        "type" => Token::Type,
        "import" => Token::Import,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "=" => Token::Equals,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "," => Token::Comma,
        ";" => Token::Semi,
        ":" => Token::Colon,
        "->" => Token::Arrow,
    }
}


// Value
pub Args: IDLArgs = "(" <SepBy<Arg, ",">> ")" => IDLArgs { args: <> };

Arg: IDLValue = {
    "bool" => IDLValue::Bool(<>),
    "+" <"number"> => IDLValue::Int(<>.parse::<i64>().unwrap()),
    "-" <"number"> => IDLValue::Int(format!("-{}", <>).parse::<i64>().unwrap()),
    "number" => IDLValue::Nat(<>.parse::<u64>().unwrap()),
    "text" => IDLValue::Text(<>),
    "null" => IDLValue::Null,
    "none" => IDLValue::None,
    "opt" <Arg> => IDLValue::Opt(Box::new(<>)),
    "vec" "{" <SepBy<Arg, ";">> "}" => IDLValue::Vec(<>),
    "record" "{" <SepBy<RecordField, ";">> "}" => {
        let mut id: u32 = 0;
        let mut fs: Vec<IDLField> = <>.iter().map(|f| {
          if f.has_id {
            id = f.inner.id + 1;
            f.inner.clone()
          } else {
            id = id + 1;
            IDLField { id: id - 1, val: f.inner.val.clone() }
          }
        }).collect();
        fs.sort_unstable_by_key(|IDLField { id, .. }| *id);
        IDLValue::Record(fs)
     },
    "variant" "{" <VariantField> "}" => IDLValue::Variant(Box::new(<>)),
}

Field: IDLField = {
    <n:"number"> "=" <v:Arg> => IDLField { id: n.parse::<u32>().unwrap(), val: v },
    <n:Name> "=" <v:Arg> => IDLField { id: idl_hash(&n), val: v },
}

VariantField: IDLField = {
    Field => <>,
    Name => IDLField { id: idl_hash(&<>), val: IDLValue::Null },
    "number" => IDLField { id: <>.parse::<u32>().unwrap(), val: IDLValue::Null },
}

RecordField: TmpIDLField = {
    Field => TmpIDLField { has_id: true, inner: <> },
    Arg => TmpIDLField { has_id: false, inner: IDLField { id:0, val:<> } },
}

// Type
Typ: IDLType = {
    PrimTyp => <>,
    "opt" <Typ> => IDLType::OptT(Box::new(<>)),
    "vec" <Typ> => IDLType::VecT(Box::new(<>)),
    "record" "{" <SepBy<FieldTyp, ";">> "}" => IDLType::RecordT(<>),
    "variant" "{" <SepBy<FieldTyp, ";">> "}" => IDLType::VariantT(<>),
    "func" <FuncTyp> => IDLType::FuncT(<>),
    "service" <ActorTyp> => IDLType::ServT(<>),
}

PrimTyp: IDLType = {
    "id" => {
      match PrimType::from_str(&<>) {
        Some(p) => IDLType::PrimT(p),
        None => IDLType::VarT(<>),
      }
    },
}

FieldTyp: TypeField = {
    <n:"number"> ":" <t:Typ> => TypeField { label: Label::Id(n.parse::<u32>().unwrap()), typ: t },
    <n:Name> ":" <t:Typ> => TypeField { label: Label::Named(n), typ: t },
}

FuncTyp: FuncType = {
    "(" <args:SepBy<Typ, ",">> ")" "->" "(" <rets:SepBy<Typ, ",">> ")" <modes:FuncMode*> =>
        FuncType { modes, args, rets },
}

FuncMode: FuncMode = {
    "oneway" => FuncMode::Oneway,
    "query" => FuncMode::Query,
}

ActorTyp: Vec<Binding> = {
    "{" <SepBy<MethTyp, ";">> "}" => <>
}

MethTyp: Binding = {
    <n:Name> ":" <f:FuncTyp> => Binding { id: n, typ: IDLType::FuncT(f) },
    <n:Name> ":" <id:"id"> => Binding { id: n, typ: IDLType::VarT(id) },
}

// Type declarations
Def: Dec = {
    "type" <id:"id"> "=" <t:Typ> => Dec::TypD(Binding { id: id, typ: t }),
    "import" <"text"> => Dec::ImportD(<>),
}

Actor: Binding = {
    "service" <id:"id"> <t:ActorTyp> => Binding { id: id, typ: IDLType::ServT(t) },
    "service" <id:"id"> ":" <t:"id"> => Binding { id: id, typ: IDLType::VarT(t) },
}

pub IDLProg: IDLProg = {
    <decs:SepBy<Def, ";">> <actor:Actor?> => IDLProg { decs, actor }
}

// Common util
Name: String = {
    "id" => <>,
    "text" => <>,
}

// Also allows trailing separator
SepBy<T, S>: Vec<T> = {
    <v:(<T> S)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};
