use crate::value::{IDLField, IDLValue, IDLArgs};
use crate::lexer::{Token, LexicalError};
use dfx_info::idl_hash;

grammar;

extern {
    type Location = usize;
    type Error = LexicalError;
    enum Token {
        "nat_literal" => Token::NatLiteral(<u64>),
        "int_literal" => Token::IntLiteral(<i64>),
        "bool_literal" => Token::BooleanLiteral(<bool>),
        "text_literal" => Token::TextLiteral(<String>),
        "label" => Token::Label(<String>),
        "null" => Token::Null,
        "none" => Token::None,
        "opt" => Token::Opt,
        "vec" => Token::Vec,
        "record" => Token::Record,
        "variant" => Token::Variant,
        "=" => Token::Equals,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "," => Token::Comma,
        ";" => Token::Semi,
    }
}

pub Args: IDLArgs = "(" <SepBy<Arg, ",">> ")" => IDLArgs { args: <> };

Arg: IDLValue = {
    "bool_literal" => IDLValue::Bool(<>),
    "int_literal" => IDLValue::Int(<>),
    "nat_literal" => IDLValue::Nat(<>),
    "text_literal" => IDLValue::Text(<>),
    "null" => IDLValue::Null,
    "none" => IDLValue::None,
    "opt" <Arg> => IDLValue::Opt(Box::new(<>)),
    "vec" "{" <SepBy<Arg, ";">> "}" => IDLValue::Vec(<>),
    "record" "{" <SepBy<Field, ";">> "}" => {
        let mut fs = <>;
        fs.sort_unstable_by_key(|IDLField { id, .. }| *id);
        IDLValue::Record(fs)
     },
    "variant" "{" <Field> "}" => IDLValue::Variant(Box::new(<>)),
}

Field: IDLField = {
    <n:"int_literal"> "=" <v:Arg> => IDLField { id: n as u32, val: v },
    <n:"label"> "=" <v:Arg> => IDLField { id: idl_hash(&n), val: v },
}

// Also allows trailing separator
SepBy<T, S>: Vec<T> = {
    <v:(<T> S)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};
