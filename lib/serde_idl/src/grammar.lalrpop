use crate::value::{IDLField, IDLValue, IDLArgs};
use dfx_info::idl_hash;
use std::str::FromStr;

grammar;

pub MethodCall: (Option<String>, IDLArgs) = <Text?> <Args>;

pub Args: IDLArgs = "(" <CommaSep<Arg>> ")" => IDLArgs { args: <> };

Arg: IDLValue = {
    "true" => IDLValue::Bool(true),
    "false" => IDLValue::Bool(false),
    "null" => IDLValue::Null,
    Num => IDLValue::Int(<>),
    Text => IDLValue::Text(<>),
    "opt" <Arg> => IDLValue::Opt(Box::new(<>)),
    "vec" "{" <SemicolonSep<Arg>> "}" => IDLValue::Vec(<>),
    "record" "{" <SemicolonSep<Field>> "}" => {
        let mut fs = <>;
        fs.sort_unstable_by_key(|IDLField { id, .. }| *id);
        IDLValue::Record(fs)
     }, 
    "variant" "{" <Field> "}" => IDLValue::Variant(Box::new(<>)),
}

Field: IDLField = {
    <n:Num> "=" <v:Arg> => IDLField { id: n as u32, val: v },
    <n:Text> "=" <v:Arg> => IDLField { id: idl_hash(&n), val: v },
}

Num: i64 = r"[0-9]+" => i64::from_str(<>).unwrap();
Text: String = r"[[:alpha:]]\w*" => String::from_str(<>).unwrap();

// Also allows trailing commas
CommaSep<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

SemicolonSep<T>: Vec<T> = {
    <v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};
