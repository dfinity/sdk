= IDL Serialization library in Rust

== Using the library
* Serialization
[source,rust]
#[macro_use]
extern crate serde_idl;
IDL!(&42, &Some(42), &[1,2,3])
// IDL! macro expands to:
IDLBuilder::new().arg(&42).arg(&Some(42)).arg(&[1,2,3]).to_vec().unwrap(),


* Derive serialization trait and inspect IDL type
[source,rust]
#[derive(IDLType)]
struct List { head: i32, tail: Option<Box<List>> }
let list = List { head: 42, tail: None };
assert_eq!(serde_idl::get_type(&list),
           Type::Record(vec![
               field("head", Type::Int),
               field("tail", Type::Opt(Box::new(
                   Type::Knot(TypeId::of::<List>()))))])               
);
assert_eq!(IDL!(&list),
           hex::decode("4449444c026c02a0d2aca8047c90eddae704016e00002a00").unwrap());

== Why not using serde
We end up not using `serde`, since `serde` cannot derive type information, and we cannot easily sort the field index in `struct` and `enum` by the `idl_hash`.

== Remaining items
* Deserialization
* Error handling
* Ignore extra fields, future values (subtype)
* Optimize for `new struct` type
* Import `.did` file in Rust
* Get rid of `std` dependency for `wasm` support

