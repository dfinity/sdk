type Tree = 
 variant {
   leaf;
   node: record {
           Color;
           Tree;
           record {
             AttributeKey;
             opt AttributeValue;
           };
           Tree;
         };
 };
type SubDBSizeOuterOptions = record {outer: OuterPair;};
type Streams = vec opt Order;
type ScanResult = 
 record {
   entities: vec Entity;
   nextKey: opt SK;
 };
type ScanOptions = 
 record {
   ascending: opt bool;
   limit: nat;
   skLowerBound: SK;
   skUpperBound: SK;
 };
type ScanLimitResult = 
 record {
   nextKey: opt text;
   results: vec record {
                  text;
                  AttributeValue__1;
                };
 };
type ScalingOptions = 
 record {
   autoScalingHook: AutoScalingCanisterSharedFunctionHook;
   sizeLimit: ScalingLimitType;
 };
type ScalingLimitType = 
 variant {
   count: nat;
   heapSize: nat;
 };
type SK__1 = text;
type SK = text;
type PutOptions = 
 record {
   attributes: vec record {
                     AttributeKey;
                     AttributeValue;
                   };
   sk: SK;
 };
type PK = text;
type OuterSubDBKey = nat;
type OuterPair = 
 record {
   canister: OuterCanister;
   key: OuterSubDBKey;
 };
type OuterCanister = 
 service {
   createOuter:
    (record {
       innerKey: InnerSubDBKey;
       outerKey: OuterSubDBKey;
       part: principal;
     }) ->
    (record {
       inner: record {
                canister: principal;
                key: InnerSubDBKey;
              };
       outer: record {
                canister: principal;
                key: OuterSubDBKey;
              };
     });
   deleteInner: (record {
                   innerKey: InnerSubDBKey;
                   sk: SK__1;
                 }) -> ();
   deleteSubDBInner: (record {innerKey: InnerSubDBKey;}) -> ();
   deleteSubDBOuter: (record {outerKey: OuterSubDBKey;}) -> ();
   getByInner: (record {
                  innerKey: InnerSubDBKey;
                  sk: SK__1;
                }) -> (opt AttributeValue__1) query;
   getByOuter: (record {
                  outerKey: OuterSubDBKey;
                  sk: SK__1;
                }) -> (opt AttributeValue__1);
   getInner: (record {outerKey: OuterSubDBKey;}) ->
    (opt record {
           canister: principal;
           key: InnerSubDBKey;
         }) query;
   getOuter: (GetByOuterPartitionKeyOptions) -> (opt AttributeValue__1);
   getSubDBUserDataInner: (record {innerKey: InnerSubDBKey;}) -> (opt text);
   getSubDBUserDataOuter: (GetUserDataOuterOptions) -> (opt text);
   hasByInner: (record {
                  innerKey: InnerSubDBKey;
                  sk: SK__1;
                }) -> (bool) query;
   hasByOuter: (record {
                  outerKey: OuterSubDBKey;
                  sk: SK__1;
                }) -> (bool);
   hasSubDBByInner: (record {innerKey: InnerSubDBKey;}) -> (bool) query;
   hasSubDBByOuter: (record {outerKey: OuterSubDBKey;}) -> (bool);
   isOverflowed: () -> (bool) query;
   putLocation:
    (record {
       innerCanister: principal;
       newInnerSubDBKey: InnerSubDBKey;
       outerKey: OuterSubDBKey;
     }) -> ();
   rawDeleteSubDB: (record {innerKey: InnerSubDBKey;}) -> ();
   rawGetSubDB: (record {innerKey: InnerSubDBKey;}) ->
    (opt record {
           map: vec record {
                      SK__1;
                      AttributeValue__1;
                    };
           userData: text;
         }) query;
   rawInsertSubDB:
    (record {
       hardCap: opt nat;
       innerKey: opt InnerSubDBKey;
       map: vec record {
                  SK__1;
                  AttributeValue__1;
                };
       userData: text;
     }) -> (record {innerKey: InnerSubDBKey;});
   rawInsertSubDBAndSetOuter:
    (record {
       hardCap: opt nat;
       keys: opt record {
                   innerKey: InnerSubDBKey;
                   outerKey: OuterSubDBKey;
                 };
       map: vec record {
                  SK__1;
                  AttributeValue__1;
                };
       userData: text;
     }) -> (record {
              innerKey: InnerSubDBKey;
              outerKey: OuterSubDBKey;
            });
   scanLimitInner:
    (record {
       dir: Direction;
       innerKey: InnerSubDBKey;
       limit: nat;
       lowerBound: SK__1;
       upperBound: SK__1;
     }) -> (ScanLimitResult) query;
   scanLimitOuter:
    (record {
       dir: Direction;
       limit: nat;
       lowerBound: SK__1;
       outerKey: OuterSubDBKey;
       upperBound: SK__1;
     }) -> (ScanLimitResult);
   scanSubDBs: () ->
    (vec
      record {
        OuterSubDBKey;
        record {
          canister: principal;
          key: InnerSubDBKey;
        };
      }) query;
   startInsertingImpl:
    (record {
       innerKey: InnerSubDBKey;
       sk: SK__1;
       value: AttributeValue__1;
     }) -> ();
   subDBSizeByInner: (record {innerKey: InnerSubDBKey;}) -> (opt nat) query;
   subDBSizeByOuter: (record {outerKey: OuterSubDBKey;}) -> (opt nat);
   subDBSizeOuterImpl: (SubDBSizeOuterOptions) -> (opt nat);
   superDBSize: () -> (nat) query;
 };
type Order = 
 record {
   order: record {
            OuterCanister;
            OuterSubDBKey;
          };
   reverse: record {
              OuterCanister;
              OuterSubDBKey;
            };
 };
type ItemTransfer = 
 record {
   communal: bool;
   data: ItemData;
 };
type ItemDetails = 
 variant {
   folder;
   link: text;
   message;
   post;
 };
type ItemDataWithoutOwner = 
 record {
   description: text;
   details: ItemDetails;
   locale: text;
   price: float64;
   title: text;
 };
type ItemData = 
 record {
   creator: principal;
   edited: bool;
   item: ItemDataWithoutOwner;
 };
type InnerSubDBKey = nat;
type GetUserDataOuterOptions = record {outer: OuterPair;};
type GetOptions = record {sk: SK;};
type GetByOuterPartitionKeyOptions = 
 record {
   outer: OuterPair;
   sk: SK__1;
 };
type Entity = 
 record {
   attributes: AttributeMap;
   pk: PK;
   sk: SK;
 };
type Direction = 
 variant {
   bwd;
   fwd;
 };
type DeleteOptions = record {sk: SK;};
type Color = 
 variant {
   B;
   R;
 };
type CanDBPartition = 
 service {
   delete: (DeleteOptions) -> ();
   get: (GetOptions) -> (opt Entity) query;
   getAttribute: (GetOptions, text) -> (opt AttributeValue) query;
   getItem: (nat) -> (opt ItemTransfer);
   getOwners: () -> (vec principal) query;
   /// @recommended (not required) public API
   getPK: () -> (text) query;
   getStreams: (nat, text) -> (opt Streams) query;
   put: (PutOptions) -> ();
   putAttribute:
    (record {
       key: AttributeKey;
       sk: SK;
       value: AttributeValue;
     }) -> ();
   putExisting: (PutOptions) -> (bool);
   putExistingAttribute:
    (record {
       key: AttributeKey;
       sk: SK;
       value: AttributeValue;
     }) -> (bool);
   scan: (ScanOptions) -> (ScanResult) query;
   setOwners: (vec principal) -> ();
   /// @required public API (Do not delete or change)
   skExists: (text) -> (bool) query;
   /// @required public API (Do not delete or change)
   transferCycles: () -> ();
 };
type AutoScalingCanisterSharedFunctionHook = func (text) -> (text);
type AttributeValue__1 = 
 variant {
   arrayBool: vec bool;
   arrayFloat: vec float64;
   arrayInt: vec int;
   arrayText: vec text;
   "bool": bool;
   float: float64;
   "int": int;
   "text": text;
   tuple: vec AttributeValuePrimitive__1;
 };
type AttributeValuePrimitive__1 = 
 variant {
   "bool": bool;
   float: float64;
   "int": int;
   "text": text;
 };
type AttributeValuePrimitive = 
 variant {
   "bool": bool;
   float: float64;
   "int": int;
   "text": text;
 };
type AttributeValue = 
 variant {
   arrayBool: vec bool;
   arrayFloat: vec float64;
   arrayInt: vec int;
   arrayText: vec text;
   "bool": bool;
   float: float64;
   "int": int;
   "text": text;
   tuple: vec AttributeValuePrimitive;
 };
type AttributeMap = 
 variant {
   leaf;
   node: record {
           Color;
           Tree;
           record {
             AttributeKey;
             opt AttributeValue;
           };
           Tree;
         };
 };
type AttributeKey = text;
service : (record {
             owners: opt vec principal;
             partitionKey: text;
             scalingOptions: ScalingOptions;
           }) -> CanDBPartition
