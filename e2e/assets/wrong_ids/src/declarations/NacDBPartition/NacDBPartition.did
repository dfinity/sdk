type SubDBSizeOuterOptions = record {outer: OuterPair;};
type ScanLimitResult__1 = 
 record {
   nextKey: opt text;
   results: vec record {
                  text;
                  AttributeValue;
                };
 };
type ScanLimitResult = 
 record {
   nextKey: opt text;
   results: vec record {
                  text;
                  AttributeValue;
                };
 };
type SK = text;
type Partition = 
 service {
   createOuter:
    (record {
       innerKey: InnerSubDBKey;
       outerKey: OuterSubDBKey;
       part: principal;
     }) ->
    (record {
       inner: record {
                canister: principal;
                key: InnerSubDBKey;
              };
       outer: record {
                canister: principal;
                key: OuterSubDBKey;
              };
     });
   deleteInner: (record {
                   innerKey: InnerSubDBKey;
                   sk: SK;
                 }) -> ();
   deleteSubDBInner: (record {innerKey: InnerSubDBKey;}) -> ();
   deleteSubDBOuter: (record {outerKey: OuterSubDBKey;}) -> ();
   getByInner: (record {
                  innerKey: InnerSubDBKey;
                  sk: SK;
                }) -> (opt AttributeValue) query;
   getByOuter: (record {
                  outerKey: OuterSubDBKey;
                  sk: SK;
                }) -> (opt AttributeValue);
   getInner: (record {outerKey: OuterSubDBKey;}) ->
    (opt record {
           canister: principal;
           key: InnerSubDBKey;
         }) query;
   getOuter: (GetByOuterPartitionKeyOptions) -> (opt AttributeValue);
   getOwners: () -> (vec principal) query;
   getSubDBUserDataInner: (record {innerKey: InnerSubDBKey;}) -> (opt text);
   getSubDBUserDataOuter: (GetUserDataOuterOptions) -> (opt text);
   hasByInner: (record {
                  innerKey: InnerSubDBKey;
                  sk: SK;
                }) -> (bool) query;
   hasByOuter: (record {
                  outerKey: OuterSubDBKey;
                  sk: SK;
                }) -> (bool);
   hasSubDBByInner: (record {innerKey: InnerSubDBKey;}) -> (bool) query;
   hasSubDBByOuter: (record {outerKey: OuterSubDBKey;}) -> (bool);
   isOverflowed: () -> (bool) query;
   putLocation:
    (record {
       innerCanister: principal;
       newInnerSubDBKey: InnerSubDBKey;
       outerKey: OuterSubDBKey;
     }) -> ();
   rawDeleteSubDB: (record {innerKey: InnerSubDBKey;}) -> ();
   rawGetSubDB: (record {innerKey: InnerSubDBKey;}) ->
    (opt record {
           map: vec record {
                      SK;
                      AttributeValue;
                    };
           userData: text;
         }) query;
   rawInsertSubDB:
    (record {
       hardCap: opt nat;
       innerKey: opt InnerSubDBKey;
       map: vec record {
                  SK;
                  AttributeValue;
                };
       userData: text;
     }) -> (record {innerKey: InnerSubDBKey;});
   rawInsertSubDBAndSetOuter:
    (record {
       hardCap: opt nat;
       keys: opt record {
                   innerKey: InnerSubDBKey;
                   outerKey: OuterSubDBKey;
                 };
       map: vec record {
                  SK;
                  AttributeValue;
                };
       userData: text;
     }) -> (record {
              innerKey: InnerSubDBKey;
              outerKey: OuterSubDBKey;
            });
   scanLimitInner:
    (record {
       dir: Direction__1;
       innerKey: InnerSubDBKey;
       limit: nat;
       lowerBound: SK;
       upperBound: SK;
     }) -> (ScanLimitResult__1) query;
   scanLimitOuter:
    (record {
       dir: Direction__1;
       limit: nat;
       lowerBound: SK;
       outerKey: OuterSubDBKey;
       upperBound: SK;
     }) -> (ScanLimitResult__1);
   scanSubDBs: () ->
    (vec
      record {
        OuterSubDBKey;
        record {
          canister: principal;
          key: InnerSubDBKey;
        };
      }) query;
   setOwners: (vec principal) -> ();
   startInsertingImpl:
    (record {
       innerKey: InnerSubDBKey;
       sk: SK;
       value: AttributeValue;
     }) -> ();
   subDBSizeByInner: (record {innerKey: InnerSubDBKey;}) -> (opt nat) query;
   subDBSizeByOuter: (record {outerKey: OuterSubDBKey;}) -> (opt nat);
   subDBSizeOuterImpl: (SubDBSizeOuterOptions) -> (opt nat);
   superDBSize: () -> (nat) query;
 };
type OuterSubDBKey = nat;
type OuterPair = 
 record {
   canister: OuterCanister;
   key: OuterSubDBKey;
 };
type OuterCanister = 
 service {
   createOuter:
    (record {
       innerKey: InnerSubDBKey;
       outerKey: OuterSubDBKey;
       part: principal;
     }) ->
    (record {
       inner: record {
                canister: principal;
                key: InnerSubDBKey;
              };
       outer: record {
                canister: principal;
                key: OuterSubDBKey;
              };
     });
   deleteInner: (record {
                   innerKey: InnerSubDBKey;
                   sk: SK;
                 }) -> ();
   deleteSubDBInner: (record {innerKey: InnerSubDBKey;}) -> ();
   deleteSubDBOuter: (record {outerKey: OuterSubDBKey;}) -> ();
   getByInner: (record {
                  innerKey: InnerSubDBKey;
                  sk: SK;
                }) -> (opt AttributeValue) query;
   getByOuter: (record {
                  outerKey: OuterSubDBKey;
                  sk: SK;
                }) -> (opt AttributeValue);
   getInner: (record {outerKey: OuterSubDBKey;}) ->
    (opt record {
           canister: principal;
           key: InnerSubDBKey;
         }) query;
   getOuter: (GetByOuterPartitionKeyOptions) -> (opt AttributeValue);
   getSubDBUserDataInner: (record {innerKey: InnerSubDBKey;}) -> (opt text);
   getSubDBUserDataOuter: (GetUserDataOuterOptions) -> (opt text);
   hasByInner: (record {
                  innerKey: InnerSubDBKey;
                  sk: SK;
                }) -> (bool) query;
   hasByOuter: (record {
                  outerKey: OuterSubDBKey;
                  sk: SK;
                }) -> (bool);
   hasSubDBByInner: (record {innerKey: InnerSubDBKey;}) -> (bool) query;
   hasSubDBByOuter: (record {outerKey: OuterSubDBKey;}) -> (bool);
   isOverflowed: () -> (bool) query;
   putLocation:
    (record {
       innerCanister: principal;
       newInnerSubDBKey: InnerSubDBKey;
       outerKey: OuterSubDBKey;
     }) -> ();
   rawDeleteSubDB: (record {innerKey: InnerSubDBKey;}) -> ();
   rawGetSubDB: (record {innerKey: InnerSubDBKey;}) ->
    (opt record {
           map: vec record {
                      SK;
                      AttributeValue;
                    };
           userData: text;
         }) query;
   rawInsertSubDB:
    (record {
       hardCap: opt nat;
       innerKey: opt InnerSubDBKey;
       map: vec record {
                  SK;
                  AttributeValue;
                };
       userData: text;
     }) -> (record {innerKey: InnerSubDBKey;});
   rawInsertSubDBAndSetOuter:
    (record {
       hardCap: opt nat;
       keys: opt record {
                   innerKey: InnerSubDBKey;
                   outerKey: OuterSubDBKey;
                 };
       map: vec record {
                  SK;
                  AttributeValue;
                };
       userData: text;
     }) -> (record {
              innerKey: InnerSubDBKey;
              outerKey: OuterSubDBKey;
            });
   scanLimitInner:
    (record {
       dir: Direction;
       innerKey: InnerSubDBKey;
       limit: nat;
       lowerBound: SK;
       upperBound: SK;
     }) -> (ScanLimitResult) query;
   scanLimitOuter:
    (record {
       dir: Direction;
       limit: nat;
       lowerBound: SK;
       outerKey: OuterSubDBKey;
       upperBound: SK;
     }) -> (ScanLimitResult);
   scanSubDBs: () ->
    (vec
      record {
        OuterSubDBKey;
        record {
          canister: principal;
          key: InnerSubDBKey;
        };
      }) query;
   startInsertingImpl:
    (record {
       innerKey: InnerSubDBKey;
       sk: SK;
       value: AttributeValue;
     }) -> ();
   subDBSizeByInner: (record {innerKey: InnerSubDBKey;}) -> (opt nat) query;
   subDBSizeByOuter: (record {outerKey: OuterSubDBKey;}) -> (opt nat);
   subDBSizeOuterImpl: (SubDBSizeOuterOptions) -> (opt nat);
   superDBSize: () -> (nat) query;
 };
type InnerSubDBKey = nat;
type GetUserDataOuterOptions = record {outer: OuterPair;};
type GetByOuterPartitionKeyOptions = 
 record {
   outer: OuterPair;
   sk: SK;
 };
type Direction__1 = 
 variant {
   bwd;
   fwd;
 };
type Direction = 
 variant {
   bwd;
   fwd;
 };
type AttributeValuePrimitive = 
 variant {
   "bool": bool;
   float: float64;
   "int": int;
   "text": text;
 };
type AttributeValue = 
 variant {
   arrayBool: vec bool;
   arrayFloat: vec float64;
   arrayInt: vec int;
   arrayText: vec text;
   "bool": bool;
   float: float64;
   "int": int;
   "text": text;
   tuple: vec AttributeValuePrimitive;
 };
service : (vec principal) -> Partition
