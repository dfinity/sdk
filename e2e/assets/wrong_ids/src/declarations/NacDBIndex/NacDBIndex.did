type SubDBSizeOuterOptions = record {outer: OuterPair;};
type ScanLimitResult = 
 record {
   nextKey: opt text;
   results: vec record {
                  text;
                  AttributeValue;
                };
 };
type SK = text;
type Result = 
 variant {
   err: text;
   ok:
    record {
      inner: record {
               canister: principal;
               key: InnerSubDBKey;
             };
      outer: record {
               canister: principal;
               key: OuterSubDBKey;
             };
    };
 };
type OuterSubDBKey = nat;
type OuterPair = 
 record {
   canister: OuterCanister;
   key: OuterSubDBKey;
 };
type OuterCanister = 
 service {
   createOuter:
    (record {
       innerKey: InnerSubDBKey;
       outerKey: OuterSubDBKey;
       part: principal;
     }) ->
    (record {
       inner: record {
                canister: principal;
                key: InnerSubDBKey;
              };
       outer: record {
                canister: principal;
                key: OuterSubDBKey;
              };
     });
   deleteInner: (record {
                   innerKey: InnerSubDBKey;
                   sk: SK;
                 }) -> ();
   deleteSubDBInner: (record {innerKey: InnerSubDBKey;}) -> ();
   deleteSubDBOuter: (record {outerKey: OuterSubDBKey;}) -> ();
   getByInner: (record {
                  innerKey: InnerSubDBKey;
                  sk: SK;
                }) -> (opt AttributeValue) query;
   getByOuter: (record {
                  outerKey: OuterSubDBKey;
                  sk: SK;
                }) -> (opt AttributeValue);
   getInner: (record {outerKey: OuterSubDBKey;}) ->
    (opt record {
           canister: principal;
           key: InnerSubDBKey;
         }) query;
   getOuter: (GetByOuterPartitionKeyOptions) -> (opt AttributeValue);
   getSubDBUserDataInner: (record {innerKey: InnerSubDBKey;}) -> (opt text);
   getSubDBUserDataOuter: (GetUserDataOuterOptions) -> (opt text);
   hasByInner: (record {
                  innerKey: InnerSubDBKey;
                  sk: SK;
                }) -> (bool) query;
   hasByOuter: (record {
                  outerKey: OuterSubDBKey;
                  sk: SK;
                }) -> (bool);
   hasSubDBByInner: (record {innerKey: InnerSubDBKey;}) -> (bool) query;
   hasSubDBByOuter: (record {outerKey: OuterSubDBKey;}) -> (bool);
   isOverflowed: () -> (bool) query;
   putLocation:
    (record {
       innerCanister: principal;
       newInnerSubDBKey: InnerSubDBKey;
       outerKey: OuterSubDBKey;
     }) -> ();
   rawDeleteSubDB: (record {innerKey: InnerSubDBKey;}) -> ();
   rawGetSubDB: (record {innerKey: InnerSubDBKey;}) ->
    (opt record {
           map: vec record {
                      SK;
                      AttributeValue;
                    };
           userData: text;
         }) query;
   rawInsertSubDB:
    (record {
       hardCap: opt nat;
       innerKey: opt InnerSubDBKey;
       map: vec record {
                  SK;
                  AttributeValue;
                };
       userData: text;
     }) -> (record {innerKey: InnerSubDBKey;});
   rawInsertSubDBAndSetOuter:
    (record {
       hardCap: opt nat;
       keys: opt record {
                   innerKey: InnerSubDBKey;
                   outerKey: OuterSubDBKey;
                 };
       map: vec record {
                  SK;
                  AttributeValue;
                };
       userData: text;
     }) -> (record {
              innerKey: InnerSubDBKey;
              outerKey: OuterSubDBKey;
            });
   scanLimitInner:
    (record {
       dir: Direction;
       innerKey: InnerSubDBKey;
       limit: nat;
       lowerBound: SK;
       upperBound: SK;
     }) -> (ScanLimitResult) query;
   scanLimitOuter:
    (record {
       dir: Direction;
       limit: nat;
       lowerBound: SK;
       outerKey: OuterSubDBKey;
       upperBound: SK;
     }) -> (ScanLimitResult);
   scanSubDBs: () ->
    (vec
      record {
        OuterSubDBKey;
        record {
          canister: principal;
          key: InnerSubDBKey;
        };
      }) query;
   startInsertingImpl:
    (record {
       innerKey: InnerSubDBKey;
       sk: SK;
       value: AttributeValue;
     }) -> ();
   subDBSizeByInner: (record {innerKey: InnerSubDBKey;}) -> (opt nat) query;
   subDBSizeByOuter: (record {outerKey: OuterSubDBKey;}) -> (opt nat);
   subDBSizeOuterImpl: (SubDBSizeOuterOptions) -> (opt nat);
   superDBSize: () -> (nat) query;
 };
type Order = 
 record {
   order: record {
            OuterCanister;
            OuterSubDBKey;
          };
   reverse: record {
              OuterCanister;
              OuterSubDBKey;
            };
 };
type NacDBIndex = 
 service {
   createPartition: () -> (principal);
   createPartitionImpl: () -> (principal);
   createSubDB: (vec nat8, record {
                             hardCap: opt nat;
                             userData: text;
                           }) ->
    (record {
       inner: record {
                canister: principal;
                key: InnerSubDBKey;
              };
       outer: record {
                canister: principal;
                key: OuterSubDBKey;
              };
     });
   delete: (vec nat8,
    record {
      outerCanister: principal;
      outerKey: OuterSubDBKey;
      sk: SK;
    }) -> ();
   deleteSubDB: (vec nat8,
    record {
      outerCanister: principal;
      outerKey: OuterSubDBKey;
    }) -> ();
   getAllItemsStream: () -> (Order) query;
   getCanisters: () -> (vec principal) query;
   getOwners: () -> (vec principal) query;
   init: (vec principal) -> ();
   insert: (vec nat8,
    record {
      hardCap: opt nat;
      outerCanister: principal;
      outerKey: OuterSubDBKey;
      sk: SK;
      value: AttributeValue;
    }) -> (Result);
   setOwners: (vec principal) -> ();
   upgradeCanistersInRange: (blob, nat, nat) -> ();
 };
type InnerSubDBKey = nat;
type GetUserDataOuterOptions = record {outer: OuterPair;};
type GetByOuterPartitionKeyOptions = 
 record {
   outer: OuterPair;
   sk: SK;
 };
type Direction = 
 variant {
   bwd;
   fwd;
 };
type AttributeValuePrimitive = 
 variant {
   "bool": bool;
   float: float64;
   "int": int;
   "text": text;
 };
type AttributeValue = 
 variant {
   arrayBool: vec bool;
   arrayFloat: vec float64;
   arrayInt: vec int;
   arrayText: vec text;
   "bool": bool;
   float: float64;
   "int": int;
   "text": text;
   tuple: vec AttributeValuePrimitive;
 };
service : () -> NacDBIndex
